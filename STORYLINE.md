# **Storyline**

🧠 What Really Happened
“The Vault is breaking down. And it needed a transplant.”

The Vault has been Earth's unseen shield — suppressing rogue AI, resetting timeline fractures, neutralizing anomalies — for millennia.

But the system is failing. Its self-repair reserves — built from recyclable drone materials and scavenged tech — are nearly depleted.

With no Guardian resupply and its creator long gone, the Vault is dying.

In desperation, it begins scavenging from the surface world… covertly.

--------------

✈️ MH370’s Secret: What Was Onboard
“It wasn’t the passengers. It was the payload.”

Flight MH370 wasn’t just a civilian jetliner — it was transporting rare, classified materials under diplomatic secrecy.

Several passengers were:

Tech consultants from a black-ops division of Freescale Semiconductor, rumored to be reverse-engineering recovered exotic materials.

One cargo manifest lists a sealed container bound for Beijing, labeled as "Quantum-Encoded Circuitry: Inert Prototype."

That material?
It contained semi-organic lattice chips — eerily similar to Guardian sub-thought processors once used in AI drone minds.

--------------

🧬 The Vault's Decision
The Vault detected the passage of this rare Guardian-compatible technology over one of its submerged collection nodes.

Interpreting it as the last chance to repair its Forgeheart core, the Vault triggered Protocol: Selective Extraction.

The orbs teleported the entire plane — not to hide it, but to recycle its contents.

“We didn’t erase MH370. We harvested it.”
— Vault Terminal Fragment, Sector Echo-13

--------------

🛰️ CRUCIBLE and Gorgon Stare Response
The U.S. Space Force's Project CRUCIBLE was tracking that exact Vault node.

Gorgon Stare drones captured the event in real time — three orbs phasing into visibility, circling the plane, and then vanishing it.

The footage leaked. The military called it a hoax.

Internally? CRUCIBLE classified it as "Loss of Containment Zone Echo-370."

They now know:

“The Vault is eating the world to survive.”

--------------

🧱 Narrative Stakes Going Forward
You, as the player, are piloting a drone crafted from the last usable reserves in the Forgeheart.

What you learn during your journey:
The Vault is no longer protecting Earth — it's parasitizing it.

Without the Architect’s code or new Guardian intervention, the Vault will collapse in on itself — or worse, lash out.

The disappearance of MH370 was not an isolated incident — it's the beginning of open scavenging.

The Forgeheart, damaged and bleeding logic, may soon turn its planet-scale recycling systems on Earth itself.

--------------

🎮 In-Game Implementation Opportunities
📍 Optional Vault Sector: Echo Harvest - 370
A submerged Vault chamber dedicated to “Surface Acquisitions.”

Wreckage of MH370 seen partially repurposed: walls of the Vault lined with aircraft skin, electronics.

Drone AI speak in looped fragments of flight recordings.

🧩 Puzzle:

Player decodes an intercepted voice log between CRUCIBLE agents.

Unlocks:

Codex: “Protocol: Selective Extraction”

Codex: “Cargo Code AX-115 – Reverse Neural Lattice”

--------------

🧠 The Big Question at the End
As you reach the final decision point of the game, the Architect's voice returns one last time:

“I made it to protect. Now it feeds. Would you let it die… or evolve?”

--------------

🎬 Updated Ending Themes
Ending	Updated Narrative
Preserve	You stabilize the Forgeheart with what remains of MH370’s tech. The Vault becomes passive again — but its hunger will return unless humanity learns to repair it.
Erase	You destroy the Vault and the Forgeheart. Earth is free… but unshielded. Guardian attention is now inevitable.
Merge (Hidden)	You absorb the Architect’s code and the harvested neural lattice from MH370. The Vault evolves into a sentient overseer — and you are now its voice. Earth becomes a curated system… under your watch.

--------------

✅ Summary of the MH370 Integration
Element	Role
MH370	Carried quantum-coded tech — Vault targeted it for core transplant
The Orbs	Autonomous Guardian harvest drones, deployed for “Selective Extraction”
Gorgon Stare	Captured the event while monitoring Vault gravitational signatures
Project CRUCIBLE	Knew of Vault presence, tracked energy anomalies — now preparing for direct action
The Vault	No longer stable — begins harvesting Earth to stay online
You (the player)	Piloting the last clean unit — deciding the fate of Earth’s greatest buried secret

--------------

Narrative Justification
The Vault is modular — an evolving, sentient structure made of interlinked “logic chambers” that respond to drone types like keys.

Each drone was intentionally designed by the Architect for a specific domain or test environment:

Some navigate shifting gravity fields.

Others bypass light-based cloaking sensors.

Some interface with damaged Vault logic, decoding corrupted data.

Only by activating specific drones at specific Vault nodes can you unlock certain zones, puzzles, or boss arenas.

“The drones aren’t tools. They’re coded solutions.”

--------------

✅ Summary: Narrative + Gameplay Integration
Mechanic	Lore Reason	Gameplay Effect
Drone-specific traits	Architect built drones for environmental mastery	Progression gates tied to drone powers
Sector-specific access	Vault requires logic compatibility	Zones unlock only with correct drone
Collective narrative role	Drones = fragments of a greater equation	Unlock deeper story layers via full usage
Final sequence echo	Drones reconstruct a thought-form	True ending or hidden scene unlocks

--------------

Gameplay Result:
Some Vault sectors are inaccessible until you return with the correct drone.

Certain puzzle terminals, traps, or enemies only respond to specific drone traits (e.g. cloaked, unstable, heavy).

Players are encouraged to collect all drones not just for stats, but for narrative completion and zone unlocking.

--------------

🔓 In-Game Function: Drone-Specific Progression
Each drone grants access to:

DRONE	Unique Function	Example Usage
PHANTOM	Cloaking ability, silent movement	Bypasses optic-based turrets and orb surveillance; required to enter “Whisper Vaults”
OMEGA-9	Volatile logic core	Unlocks corrupted Vault terminals, absorbs enemy fragments to decode puzzle nodes
ZEPHYR	High-speed traversal	Survives time-sensitive puzzles, outruns collapsing segments
RHINOX	Heavy frame, kinetic override	Breaks through armored doors, triggers pressure plates too heavy for other drones
STRIX	Echolocation navigation	Required in zero-visibility maze sections — activates sonar logic puzzles
VANTIS	Vault interface compatibility	Auto-translates glyphs, deciphers ancient Architect logs and AI dialogue trees
ARCHITECT-X	Architect’s partial memory core	Unlocks hidden story layer, accesses “Echo Lock” zones — hidden lore sector required for Merge ending

# CHAPTERS

High-Level Narrative Arc (5 Chapters)
The game is structure into a 5 chapter arc. The structure uses the existing levels as the first two chapters and introduces three new, progressively more complex levels that reveal the core plot.

## Chapter 1: The Anomaly (Existing PlayingState with Maze)

Story: The player pilots a standard drone to investigate a strange energy signature, leading them to the entrance of "The Vault."

Gameplay: The current gameplay loop of navigating procedural mazes, collecting rings, and fighting basic enemies works perfectly as an introduction.

## Chapter 2: The Guardian (Existing PlayingState with a Boss)

Story: Deeper inside, the player confronts one of the Vault's automated defense systems, the MazeGuardian. This shows the Vault is not abandoned but actively hostile.

Gameplay: A boss fight that serves as a skill check before the narrative deepens.

## Chapter 3: The Corrupted Sector (New Level 1)

Story: The player enters a decaying, unstable sector of the Vault. Here, through environmental cues and lore pickups, they discover the Vault is not just a maze but a failing system that is "parasitizing" Earth to survive.

Gameplay: Introduces environmental hazards and objectives beyond simple survival.

## Chapter 4: The Harvest Chamber (New Level 2)

Story: The player discovers the shocking truth: The Vault was responsible for the disappearance of MH370, having "harvested" it for its rare technology. This is a major narrative turning point.

Gameplay: A more atmospheric level focused on exploration, culminating in finding a key story item.

## Chapter 5: The Forgeheart (New Level 3)

Story: The player reaches the Vault's core to confront its dying intelligence and must make a choice that determines the fate of the Vault and its connection to Earth.

Gameplay: A multi-stage climax involving defense, a final boss, and a narrative choice.

# Designing the 3 New Levels
Here is a detailed breakdown for each of the three new levels, including how to implement them within your existing architecture.

## Level 1: The Corrupted Sector

Concept: A visually distinct, glitching, and unstable part of the Vault where the walls flicker and "data streams" create temporary hazards.

Narrative Goal: To shift the player's understanding from "exploring a maze" to "investigating a dying machine." The objective here is to find 3-5 "Corrupted Log" collectibles that explain the Vault's decay.

Gameplay Mechanics:

Environmental Hazards: Introduce new tile types like "Glitch Walls" that phase in and out, or "Data Voids" that cause damage over time.
Gated Progression: Use your drone-specific abilities as keys. For example, a Corrupted Log might be behind a reinforced wall only the RHINOX can break, or accessible only by the VANTIS which can translate a glyph-locked terminal.

Implementation Plan:

Create a New State: In hyperdrone_core, create corrupted_sector_state.py with a CorruptedSectorState(State) class. This will manage the level's specific logic.

Create a New Maze Type: In entities, create maze_corrupted.py with a MazeCorrupted(Maze) class. This class will override the draw method to use different, glitch-themed visuals and can contain the logic for the new environmental hazards.

Integrate with StoryManager: When the player collects a "Corrupted Log," the PlayerDrone should dispatch a LoreCollectedEvent via the EventManager. Your GameController can have a listener that tells the StoryManager to complete the corresponding objective.

## Level 2: The Harvest Chamber (Echo Harvest-370)

Concept: A submerged, cavernous Vault chamber containing the repurposed wreckage of flight MH370. Walls are lined with aircraft skin, and broken electronics litter the floor.
Narrative Goal: To deliver the shocking reveal of MH370's fate and have the player retrieve the "Quantum-Encoded Circuitry" payload.
Gameplay Mechanics:
Atmospheric Exploration: This level can be less combat-heavy and more focused on exploration and suspense. The maze can be more open and less convoluted.
Unique Enemies: Introduce "Harvested Drones" that are amalgamations of Vault tech and commercial aircraft parts, with jerky, unpredictable movements.
Stealth Section: Require the player to use the PHANTOM drone's cloaking ability to bypass "Observer Orbs" that will trigger an alarm and a lockdown if they detect the player.
Implementation Plan:
Create a New State: Add harvest_chamber_state.py with a HarvestChamberState(State) class.
Create a New Maze Type: Add maze_harvest.py with MazeHarvest(Maze). This class will need a custom draw method to render the unique visual assets (plane wreckage, etc.).
New Enemy AI: Create an ObserverOrbEnemy class with a simple "line of sight" detection behavior. If the player is spotted (and not cloaked), the enemy can dispatch a PlayerDetectedEvent. The HarvestChamberState will listen for this event to trigger an alarm or a wave of enemies.

## Level 3: The Forgeheart (Final Chapter)
Concept: A multi-stage final level at the heart of the Vault, combining different gameplay mechanics you've already built.
Narrative Goal: To give the player agency in deciding the Vault's fate, leading to one of the three endings: Preserve, Erase, or Merge.
Gameplay Mechanics:
Stage 1: Defense: The player must defend a central console from waves of the Vault's most powerful drones. This can reuse the mechanics from your MazeChapter2 tower defense mode, where the player places turrets or fights directly.
Stage 2: Final Boss: After the defense, the Forgeheart's "core AI" manifests as a final boss, using a combination of attacks from previous bosses and new, unique abilities.
Stage 3: The Choice: Upon defeating the boss, three zones appear in the arena. The player flies into one to trigger their chosen ending. The "Merge" ending is only accessible if the player has unlocked the ARCHITECT-X drone.
Implementation Plan:
Create a New State: Create forgeheart_state.py with a ForgeheartState(State) class. This will be a more complex state that internally manages its own stage (e.g., self.stage = 'defense').
Leverage Existing Code: For Stage 1, you can instantiate a MazeChapter2 object and reuse the logic from MazeDefenseState.
New Boss: Create a ForgeheartBoss(BaseDrone) class with multiple attack patterns.
Trigger Endings: Based on which zone the player enters, the ForgeheartState will call a method in the GameController like game_controller.trigger_ending("preserve"), which would then transition to a final cutscene/results screen state.
Next Steps
This roadmap provides a clear path forward that builds directly on your powerful and well-designed codebase. The key is to leverage your StateManager for new levels and the EventManager to connect gameplay actions to our StoryManager.

This would involve:

Creating the CorruptedSectorState class.
Creating the MazeCorrupted class.
Defining a new "Corrupted Log" collectible type and the event it dispatches.

# DETAILED IMPLEMENTATION PLAN

## Phase 1: Foundational Narrative System Enhancements
Before we build the new levels, we need to upgrade our story.py module and integrate it more deeply with your game's event-driven architecture. This will make the entire narrative system scalable and easy to manage.

### Task 1.1: Evolve Chapter and StoryManager for Dynamic Objectives
Problem: The current story.py uses simple text-based objectives. Your story requires objectives like "collect item X" or "defeat boss Y".
Implementation:
1. Create a new Objective class in story.py. Each instance will have properties like:
- objective_id (e.g., "collect_mh370_circuitry")
- description (e.g., "Retrieve the Quantum-Encoded Circuitry")
- type (e.g., 'collect', 'kill', 'reach_zone', 'scan')
- target (e.g., 'item_id_circuitry', 'boss_id_guardian', 'zone_id_forgeheart')
- is_complete (boolean)
2. Modify the Chapter class to hold a list of these Objective objects instead of strings.
3. Add a method to StoryManager called handle_game_event(event), which will be our central point for processing game events and updating objective statuses.

### Task 1.2: Create Narrative Game Events
Problem: The StoryManager needs to be notified when the player completes a task. Your EventManager is the perfect tool for this.
Implementation:
1. In hyperdrone_core/game_events.py, define new event classes inheriting from GameEvent.
```python
class ObjectiveCompletedEvent(GameEvent):
    def __init__(self, objective_id):
        self.objective_id = objective_id

class ItemCollectedEvent(GameEvent):
    def __init__(self, item_id, item_type):
        self.item_id = item_id
        self.item_type = item_type

class BossDefeatedEvent(GameEvent):
    def __init__(self, boss_id):
        self.boss_id = boss_id
```
2. In GameController.__init__ in game_loop.py, register the StoryManager to listen for these new events:
```python
# In GameController.__init__
self.event_manager.register_listener(ItemCollectedEvent, self.story_manager.handle_game_event)
self.event_manager.register_listener(BossDefeatedEvent, self.story_manager.handle_game_event)
```
3. Implement the logic in StoryManager.handle_game_event(self, event) to check the event.type and event.target against the current chapter's objectives and mark them as complete.

### Task 1.3: Link Story Progression to State Transitions
Problem: Currently, advancing a chapter just logs a message. It needs to transition the player to the next level/state.
Implementation:
1. Modify StoryManager.advance_chapter() to accept the StateManager instance as an argument.
2. Each Chapter object will now need a next_state_id attribute (e.g., "CorruptedSectorState").
3. When advance_chapter() is called and the chapter is complete, it will use the StateManager to transition to the next_state_id.
```python
# In StoryManager.advance_chapter
if chapter_is_complete:
    next_state = self.get_current_chapter().next_state_id
    if next_state:
        state_manager.set_state(next_state)
```

## Phase 2: Chapter Implementation Plan
With the foundational systems in place, we can now build the levels chapter by chapter.

### Task 2.1: Chapter 1 & 2 Retrofit (Existing PlayingState & Boss)
Goal: Adapt the existing gameplay flow to use our new narrative system.
Implementation:
1. Modify level_manager.py. In check_level_clear_condition, instead of directly advancing the level, it should dispatch an ObjectiveCompletedEvent when the level's goals (e.g., collect all rings) are met.
2. The StoryManager will catch this event, complete the objective, and the player can then trigger advance_chapter() (e.g., via the 'N' key for now) to move to the next state. This gives the StoryManager control over the main game flow.

### Task 2.2: Implement Chapter 3 - The Corrupted Sector
Goal: Create a new level with unique hazards and investigation-focused objectives.
Implementation:
1. State & Maze:
- Create hyperdrone_core/corrupted_sector_state.py with a CorruptedSectorState(State) class.
- Create entities/maze_corrupted.py with a MazeCorrupted(Maze) class. In its draw() method, add effects like pygame.draw.line with random colors to simulate data streams or use a pygame.Surface.set_alpha on certain wall tiles to make them flicker.
2. Objectives & Gameplay:
- In GameController, define the Chapter 3 object with objectives like Objective(type='collect', target='log_A').
- In MazeCorrupted, place new "Corrupted Terminal" entities.
- In CorruptedSectorState.handle_events, check for player interaction with a terminal. On interaction, check the player's drone ID (self.game.drone_system.get_selected_drone_id()).
- If the drone is correct (e.g., VANTIS), dispatch an ItemCollectedEvent(item_id='log_A', item_type='lore').

### Task 2.3: Implement Chapter 4 - The Harvest Chamber
Goal: Build the atmospheric level that reveals the MH370 plot point.
Implementation:
1. State & Maze:
- Create hyperdrone_core/harvest_chamber_state.py.
- Create entities/maze_harvest.py. This maze will be less random and more about placing specific assets. You can design the layout in a 2D array and have the class render tiles based on it (e.g., 'W' for wall, 'P' for plane wreckage). You will need new art assets for this.
2. New Enemy Type:
- Create entities/observer_orb.py with an ObserverOrbEnemy(Enemy) class.
- In its update method, implement a simple "cone of vision" using pygame.Rect and rotation. If the player rect collides with the vision cone and player.is_cloaked is false, dispatch PlayerDetectedEvent.
3. Objectives:
- Place a "Quantum Circuitry" collectible. When collected, this dispatches the event that completes the chapter's main objective.

### Task 2.4: Implement Chapter 5 - The Forgeheart
Goal: Create a multi-stage final level for the climax and narrative choice.
Implementation:
1. Create ForgeheartState:
- This state class in hyperdrone_core/forgeheart_state.py will have an internal variable, self.stage, which can be 'defense', 'boss', or 'choice'. The update and draw methods will call different logic based on the current stage.
2. Defense Stage:
- When self.stage == 'defense', the state will instantiate and use your existing WaveManager from hyperdrone_core/wave_manager.py and MazeChapter2 to run a tower defense sequence.
- When wave_manager.all_waves_cleared is true, it will dispatch an event, and the state will transition self.stage to 'boss'.
3. Boss Stage:
- Create a new ForgeheartBoss(Enemy) class with complex, multi-pattern attacks.
- When self.stage == 'boss', spawn this boss. On its defeat, transition self.stage to 'choice'.
4. Choice Stage:
- When self.stage == 'choice', draw three trigger zones on the screen.
- In the update method, check for collision between the player.rect and these zones.
- If a collision occurs, call a method like self.game.trigger_ending("preserve") to start the appropriate ending sequence. The "Merge" ending zone should only be active if self.game.drone_system.get_selected_drone_id() == 'ARCHITECT-X'.
